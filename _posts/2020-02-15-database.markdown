---
layout: post
title:  "【DB】数据库原理"
crawlertitle: "数据库原理"
summary: "Database"
date:   2020-02-15 09:00:00 +0800
categories: posts
tags: 'CSSE'
author: xusc
---

事务的ACID特性：
- 原子性（Atomicity）
- 一致性（Consistency）——执行结果正确
- 隔离性（Isolation）
- 持久性（Durability）——应对系统奔溃

并发一致性问题。产生原因：破坏了事务的隔离性；解决方法：并发控制。
- 丢失修改
- 读脏数据
- 不可重复读
- 幻读

#### 封锁
封锁粒度：行级锁、表级锁

封锁类型：
1. 读写锁
   - 互斥锁（Exclusive），简写为 X 锁，又称写锁。
   - 共享锁（Shared），简写为 S 锁，又称读锁。
2. 意向锁
   - 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
   - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

封锁协议
- 三级封锁协议
  1. 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。可以解决丢失修改问题。
  2. 二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。可以解决读脏数据问题。
  3. 三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题。
- 两段锁协议：加锁和解锁分为两个阶段进行。
  - 可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。
  - 事务遵循两段锁协议是保证可串行化调度的充分条件。

#### 隔离级别
- 未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。
- 提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。
- 可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。
- 可串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

### 关系数据库理论
- 函数依赖：记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。
- 对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。
- 键码：如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

#### 范式
不符合范式的关系，会产生主要四种异常：
- 冗余数据
- 修改异常
- 删除异常
- 插入异常

1. 第一范式 (1NF)：属性不可分。
2. 第二范式 (2NF)：每个非主属性完全函数依赖于键码。可以通过分解来满足。
3. 第三范式 (3NF)：非主属性不传递函数依赖于键码。
4. BCNF
5. 第四范式 (4NF)：

### ER图
Entity-Relationship，有三个组成部分：实体、属性、联系。