---
layout: post
title:  "【Java】"
crawlertitle: "Java"
summary: "Java知识点总结"
date:   2020-02-08 09:00:00 +0800
categories: posts
tags: 'CSSE'
author: xusc
---

Java基础

### 数据类型

基本类型|包装类型|缓冲池
:-:|:-:|:-:
int（4字节）|Integer|-128~127
byte（1字节）|Byte|
short（2字节）|Short|-128~127
long（8字节）|Long|
float（4字节）|Float|
double（8字节）|Double|
char（2字节）|Character|\u0000~\u007F
boolean（~）|Boolean|true&false

- JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。boolean 数组是通过读写 byte 数组来实现的。

```Java
// 装箱，自动将基本数据类型转换为包装器类型 调用了 Integer.valueOf(1)
Integer x = 1;
// 拆箱，自动将包装器类型转换为基本数据类型 调用了 X.intValue()
int y = x;
```

- new Integer(1) 每次都会新建一个对象；
- Integer.valueOf(1) 会使用缓存池中的对象，多次调用会取得同一个对象的引用，valueOf() 先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。

```Java
Integer a = new Integer(1);
Integer b = new Integer(1);
System.out.println(a == b);             //false
Integer c = Integer.valueOf(1);
Integer d = Integer.valueOf(1);
System.out.println(c == d);             //true
```

### String

String 被声明为 final，因此它不可被继承。在 Java 8 中，String 内部使用 char 数组存储数据。在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。
String 不可变的好处
1. 可以缓存 hash 值
2. String Pool 的需要
3. 安全性
4. 线程安全

—|String|StringBuffer|StringBuilder
:-:|:-:|:-:|:-:
可变性|不可变|可变|可变
线程安全|安全|安全|不安全

- 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。
- 在 Java 7，String Pool 被移到堆中，因为永久代的空间有限。
- 使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。
  - "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
  - 而使用 new 的方式会在堆中创建一个字符串对象。

```Java
// new String() 的方式新建了两个不同字符串
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2);               // false
// s.intern() 方法取得一个字符串引用。intern() 首先把 s 引用的字符串放到 String Pool 中，然后返回这个字符串引用。
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4);               // true
// 字面量的形式创建字符串，会自动地将字符串放入 String Pool 中
String s5 = "abc";
String s6 = "abc";
System.out.println(s5 == s6);               // true
```

### 运算

#### 传递
- 基本类型
  - 值就直接保存在变量中。
  - 赋值运算符会直接改变变量的值，原来的值被覆盖掉。
- 引用类型
  - 变量中保存的只是实际对象的地址。一般称这种变量为"引用"，引用指向实际对象，实际对象中保存着内容。
  - 赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变。

参数传递基本上就是赋值操作。
```Java
// eg1: 基本类型
void foo(int value) {
    value = 1;
}
foo(num); // num 没有被改变

// eg2: 没有提供改变自身方法的引用类型
void foo(String text) {
    text = "abc";
}
foo(str); // str 也没有被改变

// eg3: 提供了改变自身方法的引用类型
StringBuilder sb = new StringBuilder("abc");
void foo(StringBuilder builder) {
    builder.append("1");
}
foo(sb); // sb 被改变了，变成了"abc1"。

// eg4: 提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
StringBuilder sb = new StringBuilder("abc");
void foo(StringBuilder builder) {
    builder = new StringBuilder("def");
}
foo(sb); // sb 没有被改变，还是 "abc"。
```

Java 的参数是以值传递的形式传入方法中，而不是引用传递。

#### 类型转换
- 1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。1.1f 字面量才是 float 类型。
- 字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。但是使用 += 或者 ++ 运算符会执行隐式类型转换。

### 关键字
- final
  - 对于基本类型，final 使数值不变；对于引用类型，final 使引用不变。
  - 声明方法不能被子类重写。private 方法隐式地被指定为 final。如果子类中定义的方法和基类中 private 签名相同，则是新方法。
  - 声明类不允许被继承。
- static
  - 静态变量
    - 静态变量：又称为类变量，变量属于类，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
    - 实例变量：每创建一个实例就会产生一个实例变量。
  - 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。
  - 静态语句块在类初始化时运行一次。
  - 静态内部类
    - 非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。
    - 静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。
  - 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。
- 存在继承的情况下，初始化顺序为：
  1. 父类（静态变量、静态语句块）
  2. 子类（静态变量、静态语句块）
  3. 父类（实例变量、普通语句块）
  4. 父类（构造函数）
  5. 子类（实例变量、普通语句块）
  6. 子类（构造函数）

#### Object
等价与相等
- 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
- 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。

hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。

理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x<<5)-x，编译器会自动进行这个优化。

toString() 默认返回 `类名`@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。

clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。使用 clone() 方法来拷贝一个对象即复杂又有风险，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。

- 浅拷贝拷贝对象和原始对象的引用类型引用同一个对象。默认拷贝构造函数只是对对象进行浅拷贝复制（逐个成员依次拷贝），即只复制对象空间而不复制资源。
  - 对于基础类型，直接将属性值赋值给新的对象，其中一个对象修改该值，不会影响另外一个。
  - 对于引用类型，浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间，改变其中一个，会对另外一个也产生影响。
- 深拷贝拷贝对象和原始对象的引用类型引用不同对象。
  - 对于基础类型，与浅拷贝一样。
  - 对于引用类型，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。
  - 对于有多层对象的，每个对象都需要实现 Cloneable 并重写 clone() 方法。

### 继承
抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。

接口是抽象类的延伸。接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。接口的字段默认都是 static 和 final 的。

—|抽象类|接口
:-:|:-:|:-:
关系|is a|like a
继承|单个|多个
访问权限|—|public
字段|—|static、final
使用场景|需要在几个相关的类中共享代码<br/>需要能控制继承来的成员的访问权限，而不是都为 public<br/>需要继承非静态和非常量字段|需要让不相关的类都实现一个方法<br/>需要使用多重继承


[知乎](https://www.zhihu.com/question/31203609)