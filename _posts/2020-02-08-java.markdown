---
layout: post
title:  "【Java】Java知识点总结"
crawlertitle: "Java"
summary: "Java知识点总结"
date:   2020-02-08 09:00:00 +0800
categories: posts
tags: 'CSSE'
author: xusc
---

Java基础

### 目录
- [Java基础](#Java基础)
  - [数据类型](#数据类型)
    - [基本类型](#基本类型)
    - [String](#String)
  - [运算](#运算)
    - [传递](#传递)
    - [类型转换](#类型转换)
  - [关键字](#关键字)
  - [异常](#异常)
  - [JDK与JRE](#JDK与JRE)
- Java面向对象
  - [Object](#Object)
  - [继承](#继承)
- Java进阶
  - [Java容器](#Java容器)
  - [反射](#反射)
  - [泛型](#泛型)

## Java基础

### 数据类型

#### 基本类型

基本类型|包装类型|缓冲池
:-:|:-:|:-:
int（4字节）|Integer|-128~127
byte（1字节）|Byte|
short（2字节）|Short|-128~127
long（8字节）|Long|
float（4字节）|Float|
double（8字节）|Double|
char（2字节）|Character|\u0000~\u007F
boolean（~）|Boolean|true&false

- JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。boolean 数组是通过读写 byte 数组来实现的。

```Java
// 装箱，自动将基本数据类型转换为包装器类型 调用了 Integer.valueOf(1)
Integer x = 1;
// 拆箱，自动将包装器类型转换为基本数据类型 调用了 X.intValue()
int y = x;
```

- new Integer(1) 每次都会新建一个对象；
- Integer.valueOf(1) 会使用缓存池中的对象，多次调用会取得同一个对象的引用，valueOf() 先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。

```Java
Integer a = new Integer(1);
Integer b = new Integer(1);
System.out.println(a == b);             //false
Integer c = Integer.valueOf(1);
Integer d = Integer.valueOf(1);
System.out.println(c == d);             //true
```

#### String

String 被声明为 final，因此它不可被继承。在 Java 8 中，String 内部使用 char 数组存储数据。在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。
String 不可变的好处
1. 可以缓存 hash 值
2. String Pool 的需要
3. 安全性
4. 线程安全

—|String|StringBuffer|StringBuilder
:-:|:-:|:-:|:-:
可变性|不可变|可变|可变
线程安全|安全|安全|不安全

- 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。
- 在 Java 7，String Pool 被移到堆中，因为永久代的空间有限。
- 使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 "abc" 字符串对象）。
  - "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
  - 而使用 new 的方式会在堆中创建一个字符串对象。

```Java
// new String() 的方式新建了两个不同字符串
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2);               // false
// s.intern() 方法取得一个字符串引用。intern() 首先把 s 引用的字符串放到 String Pool 中，然后返回这个字符串引用。
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4);               // true
// 字面量的形式创建字符串，会自动地将字符串放入 String Pool 中
String s5 = "abc";
String s6 = "abc";
System.out.println(s5 == s6);               // true
```

### 运算

#### 传递
- 基本类型
  - 值就直接保存在变量中。
  - 赋值运算符会直接改变变量的值，原来的值被覆盖掉。
- 引用类型
  - 变量中保存的只是实际对象的地址。一般称这种变量为"引用"，引用指向实际对象，实际对象中保存着内容。
  - 赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变。

参数传递基本上就是赋值操作。Java 的参数是以值传递的形式传入方法中，而不是引用传递。

```Java
// eg1: 基本类型
void foo(int value) {
    value = 1;
}
foo(num); // num 没有被改变
// eg2: 没有提供改变自身方法的引用类型
void foo(String text) {
    text = "abc";
}
foo(str); // str 也没有被改变
// eg3: 提供了改变自身方法的引用类型
StringBuilder sb = new StringBuilder("abc");
void foo(StringBuilder builder) {
    builder.append("1");
}
foo(sb); // sb 被改变了，变成了"abc1"。
// eg4: 提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
StringBuilder sb = new StringBuilder("abc");
void foo(StringBuilder builder) {
    builder = new StringBuilder("def");
}
foo(sb); // sb 没有被改变，还是 "abc"。
```

#### 类型转换
- 1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。1.1f 字面量才是 float 类型。
- 字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。但是使用 += 或者 ++ 运算符会执行隐式类型转换。

### 关键字
- final
  - 对于基本类型，final 使数值不变；对于引用类型，final 使引用不变。
  - 声明方法不能被子类重写。private 方法隐式地被指定为 final。如果子类中定义的方法和基类中 private 签名相同，则是新方法。
  - 声明类不允许被继承。
- static
  - 静态变量
    - 静态变量：又称为类变量，变量属于类，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
    - 实例变量：每创建一个实例就会产生一个实例变量。
  - 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。
  - 静态语句块在类初始化时运行一次。
  - 静态内部类
    - 非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。
    - 静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。
  - 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。
- 存在继承的情况下，初始化顺序为：
  1. 父类（静态变量、静态语句块）
  2. 子类（静态变量、静态语句块）
  3. 父类（实例变量、普通语句块）
  4. 父类（构造函数）
  5. 子类（实例变量、普通语句块）
  6. 子类（构造函数）

### Object
1. equals() 等价与相等
   - 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
   - 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。
2. hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。
   - 理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x<<5)-x，编译器会自动进行这个优化。
3. toString() 默认返回 `类名`@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。
4. clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。使用 clone() 方法来拷贝一个对象即复杂又有风险，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。
   - 浅拷贝拷贝对象和原始对象的引用类型引用同一个对象。默认拷贝构造函数只是对对象进行浅拷贝复制（逐个成员依次拷贝），即只复制对象空间而不复制资源。
     - 对于基础类型，直接将属性值赋值给新的对象，其中一个对象修改该值，不会影响另外一个。
     - 对于引用类型，浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间，改变其中一个，会对另外一个也产生影响。
   - 深拷贝拷贝对象和原始对象的引用类型引用不同对象。
     - 对于基础类型，与浅拷贝一样。
     - 对于引用类型，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。
     - 对于有多层对象的，每个对象都需要实现 Cloneable 并重写 clone() 方法。

### 继承
- 抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。
- 接口是抽象类的延伸。

—|抽象类|接口
:-:|:-:|:-:
关系|is a|like a
继承|单个|多个
访问权限|—|public
字段|—|static、final
使用场景|需要在几个相关的类中共享代码<br/>需要能控制继承来的成员的访问权限，而不是都为 public<br/>需要继承非静态和非常量字段|需要让不相关的类都实现一个方法<br/>需要使用多重继承

1. super
   - 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。
   - 子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。
   - 如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。
2. 重写与重载
   - 重写（Override）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。
     - 子类方法的访问权限必须大于等于父类方法；
     - 子类方法的返回类型必须是父类方法返回类型或为其子类型。
     - 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。
     - 使用 @Override 注解
   - 重载（Overload）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。
3. 调用顺序
   - 在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：
     1. this.func(this)
     2. super.func(this)
     3. this.func(super)
     4. super.func(super)


### 反射
每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。Class 和 java.lang.reflect 一起对反射提供了支持。
- 反射的优点：可扩展性、类浏览器和可视化开发环境、调试器和测试工具
- 反射的缺点：性能开销、安全限制、内部暴露

### 异常
Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：
- 受检异常 ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；
- 非受检异常 ：是程序运行时错误，例如除 0 ，此时程序崩溃并且无法恢复。

### 泛型
泛型提供了编译时类型安全监测机制，该机制允许程序员在编译时监测非法的类型。泛型的本质是参数化类型，也就是所操作的数据类型被指定为一个参数。

### JDK与JRE
JRE 是 JVM 程序，Java 应用程序需要在 JRE 上运行。
JDK 是用于开发 Java 程序的 JRE ，JRE +工具的超集。例如，它提供了编译器“ javac”

[知乎](https://www.zhihu.com/question/31203609)

## Java容器
- Collection：Collection 继承了 Iterable 接口，其中 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。属于`迭代器模式`。
  - Set：无序、数据不重复
    - TreeSet：基于红黑树实现，支持有序性操作，查找的时间复杂度为 O(logN)。
    - HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作，并且失去了元素的插入顺序信息。查找的时间复杂度为 O(1)。
    - LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。
  - List：有序、数据可重复
    - [ArrayList](#arraylist)：基于动态数组实现，支持随机访问。
    - [Vector](#vector)：和 ArrayList 类似，但它是线程安全的。
    - [LinkedList](#linkedlist)：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。还可以用作栈、队列和双向队列。
  - Queue
    - [LinkedList](#linkedlist)：可以用它来实现双向队列。
    - PriorityQueue：基于堆结构实现，可以用它来实现优先队列。
- Map
  - TreeMap：基于红黑树实现。
  - [HashMap](#hashmap)：基于哈希表实现。
  - HashTable：和 HashMap 类似，但它是线程安全的。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全。使用 synchronized 来进行同步。
  - LinkedHashMap：继承自 HashMap。使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

### ArrayList
- 数组的默认大小为 10
- 添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为旧容量的 1.5 倍。扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。
- 删除元素需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上。
- ArrayList 只序列化数组中有元素填充那部分内容。

### Vector
- 它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。
- Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。默认情况下 Vector 每次扩容时容量都会翻倍。
- Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。

### CopyOnWriteArrayList
- 读写分离，写操作在一个复制的数组上进行，读操作还是在原始数组中进行。
- 适合读多写少的应用场景。不适合内存敏感以及对实时性要求很高的场景。

### LinkedList
- 基于双向链表实现，使用 Node 存储链表节点信息。
- 每个链表存储了 first 和 last 指针。

### HashMap
- 内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，是一个链表。
- put 操作使用链表的头插法，使用拉链法来解决冲突。
- HashMap 允许插入键为 null 的键值对，使用第 0 个桶存放键为 null 的键值对。
- HashMap 采用动态扩容来根据当前的 N 值（需要存储的键值对数量）来调整 M 值（ table 容量，必须保证为 2 的 n 次方），每次扩容时容量都会翻倍。扩容操作需要把 oldTable 的所有键值对重新插入 newTable 中。
- 从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。

### ConcurrentHashMap
- ConcurrentHashMap 和 HashMap 实现上类似，ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高。默认的并发级别为 16，也就是说默认创建 16 个 Segment。

### WeakHashMap
- WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。

## Java并发

### 线程
- 有三种使用线程的方法：
  1. 实现 Runnable 接口——使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。；
  2. 实现 Callable 接口；
  3. 继承 Thread 类—— Thread 类也实现了 Runable 接口。
- 实现接口优于继承 Thread：
  - Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
  - 类可能只要求可执行就行，继承整个 Thread 类开销过大。
- Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。
- Daemon 守护线程是程序运行时在后台提供服务的线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。
- Thread.sleep(millisec) 方法会休眠当前正在执行的线程。
- 线程中抛出的异常需要在本地进行处理。

### 中断
通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。调用 interrupt() 方法会设置线程的中断标记。
调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。

### 互斥同步

——|synchronized|ReentrantLock
:-:|:-:|:-:
实现|JVM|JDK
可否中断|不可|可以
是否公平锁|非公平|非公平，也可以公平

synchronized
- 同步一个代码块或方法——作用于同一个对象
- 同步一个类或静态方法——作用于整个类

