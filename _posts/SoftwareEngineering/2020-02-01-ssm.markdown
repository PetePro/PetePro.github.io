---
layout: post
title:  "【Java】SSM框架 总结 01 原理"
crawlertitle: "SSM原理"
summary: "Spring + SpringMVC + Mybatis"
date:   2020-02-01 09:00:00 +0800
categories: posts
tags: 'SE'
author: xusc
bg: "SE.jpg"
---

`SSM (Spring + SpringMVC + MyBatis)` 框架集由 Spring、MyBatis 两个开源框架整合而成，常作为数据源较简单的 Web 项目框架。本文总结SSM 框架的基本原理。

### 1 Spring

概念：Spring 是一个开源的轻量级 Java SE / Java EE 开发应用框架，其目的是用于简化企业级应用程序开发。

简化开发
- ***面向 Bean***：IoC 容器通过配置文件或者注解的方式来管理对象之间的依赖关系
- ***IoC/DI（Inversion of Control 控制反转 / Dependency Injection 依赖注入）***
  - Spring 通过控制反转（IoC）的技术促进了松耦合。
  - 依赖注入 DI。把 DAO 依赖注入到 service 层，service 层反转给 action 层，Spring 顶层容器为 BeanFactory。
- ***AOP（Aspect Oriented Programming 面向切面）***：Spring 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现业务逻辑。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。
  - 实现原理：动态代理。
  - 面向切面编程：通过预编译和运行期动态代理的方式实现在不修改源代码的情况下给程序动态添加功能的技术

Spring生命周期：
1. getBean；
2. 调用 bean 的缺省构造函数；
3. 根据 XML 中的配置设置 bean 的相关属性；
4. 检查 bean 所实现的 aware 接口；
5. BeanPostProcessor 前置处理；
6. 检查 InitializingBean 接口；
7. 检查 init-method 方法；
8. BeanPostProcessor 后置处理；
9. In Use；
10. 检查 Disposable 接口；
11. destroy 方法。

Spring 的配置文件中的内容
- 开启事务注解驱动
- 事务管理器
- 开启注解功能，并配置扫描包
- 配置数据库
- 配置 SQL 会话工厂，别名，映射文件
- 不用编写 Dao 层的实现类

#### 1.1 系统架构
+ 核心容器：spring-beans、spring-core、spring-context、spring-expression
+ AOP 和设备支持：spring-aop、spring-aspects、spring-instrumentation
+ 数据访问及集成：spring-jdbc、spring-tx、spring-orm、spring-jms、spring-oxm
+ Web：spring-web、spring-webmvc、spring-websocket、spring-webmvc-portlet
+ 报文发送：spring-messaging
+ Test：spring-test

#### 1.2 IoC/DI
IoC：想是反转资源获取的方向。传统的资源查找方式要求组件向容器发起请求查找资源，容器适时返回资源。而应用了 IOC 之后，则是容器主动将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接收资源，这种行为也被称为查找被动形式。

IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、载入和注册这三个基本的过程

DI：IOC 的另一种表达形式，即组件以一些预先定义好的方式（例如：setter 方法）接收来自如容器的资源注入。相对于 IOC 而言，这种表达更直接。Spring DI 的三种方式，即为一个 bean 设置属性
1. 属性注入：通过 setter 方法初始化，使用 `<property>` 标签（最常用）
2. 构造器注入：通过构造方法初始化，保证了 Bean 实例在实例化后就可以使用，使用 `<constructor-arg>` 标签
3. 工厂方法注入：很少用，不推荐

字面值
- 可用字符串表示的值，可以通过 `<value>` 元素标签或 value 属性进行注入
- 基本数据类型及其封装类、String等类型都可以采取字面值注入的方式

依赖注入的时间
1. 用户第一次通过 getBean 方法向 IOC 容索要 Bean 时，IOC 容器触发依赖注入
2. 当用户在 Bean 定义资源中为 `<Bean>` 元素配置了 lazy-init 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入

#### 1.3 bean及其管理
两种类型的 IOC 容器实现，Spring Bean 的创建是典型的工厂模式
- `BeanFactory` 是 Spring 中比较原始、比较古老的 Factory。
- `ApplicationContext` 是 BeanFactory 的子类，基本上代替了 BeanFactory 的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展。
  - 负责读取 Spring 配置文件，管理对象加载，生成，维护 Bean 和 Bean 对象之间的依赖关系，负责 Bean 的生命周期等
  - ApplicationContext 的主要实现类
    - `ClassPathXmlApplicationContext`：从类路径下加载配置文件
    - `FileSystemXmlApplicationContext`：从文件系统中加载配置文件
    - `WebApplicationContext`：专门为 WEB 应用而准备的，从相对于 WEB 根目录的路径中完成初始化工作

比较|BeanFactory|ApplicationContext
:-:|:-:|:-:
创建 Bean|延迟加载，调用 getBean()|容器启动时一次性创建
创建方式|编程式|声明式

配置 bean
- 命名空间：简化 xml 文件
- 自动装配（autowire）：将一个 Bean 注入到其他 Bean 的 Property 中
  - 与依赖注入的区分：依赖注入是一种设计模式，而 @autowired 是一种实现它的机制。
  - 模式：byType（根据类型自动装配）、byName（根据名称自动装配）、constructor（通过构造器自动装配，不建议使用）
- Spring 配置 bean 实例化的方式
  1. 使用类构造器实例化（默认无参数）
     `<bean id="bean1" class="cn.itcast.spring.b_instance.Bean1"></bean>`
  2. 使用静态工厂方法实例化（简单工厂模式）：调用 Bean2Factory 的 getBean2 方法得到 bean2
     `<bean id="bean2" class="cn.itcast.spring.b_instance.Bean2Factory" factory-method="getBean2"></bean>`
  3. 使用实例工厂方法实例化（工厂方法模式）：先创建工厂实例 bean3Facory，再通过工厂实例创建目标 bean 实例
     `<bean id="bean3Factory" class="cn.itcast.spring.b_instance.Bean3Factory"></bean>`
     `<bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"></bean>`

bean 作用域：在 `<bean>` 元素的 scope 属性里设置 bean 的作用域
+ singleton：在 SpringIOC 容器中仅存在一个 Bean 实例，bean 以单例的方式存在。（默认）
+ prototype：每次调用 getBean 时都会返回一个新的实例。
+ request：每次 http 请求都会创建一个新的 bean，该作用域仅适用于 WebpplicationContext 环境。
+ session：同一个 HTTP Session 共享一个 Bean，不同的 HTTP Sessionn 使用不同的 Beana.该作用域仅适用于 WebApplicationContext 环境。

bean 生命周期（IoC 容器容器管理）
1. 通过构造器或工厂方法创建 bean 实例；
2. 为 bean 的属性设置值和对其他 bean 的引用；
3. 调用 bean 的初始化方法；
4. 使用 bean；
5. 当容器关闭时，调用 bean 的销毁方法。

Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。

#### 1.4 AOP
AOP 解决的问题：代码混乱、代码分散、动态代理。

AspectJ 是 Java 社区里最完整最流行的 AOP 框架

AOP 术语
+ 切面：横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象
+ 通知：切面必须要完成的工作
+ 目标：被通知的对象
+ 代理：向目标对象应用通知之后创建的对象
+ 连接点：程序执行的某个特定位置，如类某个方法调用前、调用后、方法抛出异常后等。连接点由两个信息确定：方法表示的程序执行点；相对点表示的方位。
+ 切点：每个类都拥有多个连接点，连接点是程序类中客观存在的事务。AOP 通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对多的关系。切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。

#### 1.5 事务
Spring 事务的本质其实就是数据库对事务的支持。

Spring 事务管理：一般使用 `TransactionMananger` 进行管理，可以通过 Spring 的注入来完成此功能。
- 编程式事务管理：编程方式管理事务，极大灵活性，难维护。
- 声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。主要选择。

配置事务隔离级别
- 在 `@Transactional` 的 `isolation` 属性中设置隔离级别
- 在 `<tx:method>` 元素中指定隔离级别

#### 1.6 Spring下的注解
- **注册**：@Controller、@Service、@Repository
  - `@Controller` 对应表现层的 Bean，也就是 Action。使用 @Controller 注解标识 UserController 之后，就表示要把 UserController 交给Spring容器管理，在 Spring 容器中会存在一个名字为 “userController” 的 Action，这个名字是根据 UserController 类名来取的。
  - `@Service` 对应的是业务层 Bean。
  - `@Repository` 对应数据访问层 Bean。
- **注入**：@Autowired 与 @Resource
  - `@Autowired` 按 byType 自动注入，默认情况下必须要求依赖对象必须存在。
  - `@Resource` 默认按 byName 自动注入，有两个重要属性 name 和 type
  - @Autowired 与 @Resource 都可以用来装配 bean。都可以写在字段上，或写在 setter 方法上。
- **请求地址**：@RequestMapping
  - `@RequestMapping` 是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。@RequestMapping 注解有六个属性：value、method、consumes、produces、params、headers。
- **返回具体数据类型而非跳转**：`@ResponseBody`

Spring中主要的设计模式
- 工厂模式：每个 Bean 的创建通过方法
- 单例模式：默认的每个 Bean 的作用域都是单例
- 代理模式：关于 AOP 的实现通过代理模式
- 策略模式：定义一系列的算法，把它们一个个的封装起来，并且使它们可以相互替换。在实例化对象时用到。





### 2 SpringMVC
SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。

SpringMVC工作流程
1. 用户发送请求至前端控制器DispatcherServlet 
2. DispatcherServlet收到请求调用HandlerMapping处理器映射器。 
3. 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 
4. DispatcherServlet调用HandlerAdapter处理器适配器 
5. HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 
6. Controller执行完成返回ModelAndView 
7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet 
8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器 
9. ViewReslover解析后返回具体View 
10. DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 
11. DispatcherServlet响应用户

@RequestMapping注解用来映射一个URL到一个类或一个特定的方处理法上。

返回值
- SpringMVC中函数的返回值可以有很多类型，有String、ModelAndView、List、Set等，一般用String，如果是AJAX请求，返回的可以是一个集合
- SpringMVC根据配置文件中InternalResourceViewResolver（内部资源视图解析器）的前缀和后缀，用前缀+返回值+后缀组成完整的返回值
- 转发：在返回值前面加"forward:"
- 重定向：在返回值前面加"redirect:"



### 3 Mybatis
MyBatis 是一个持久层框架，它对 jdbc 的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理 jdbc 繁杂的过程代码。

MyBatis 优点
- 半自动化的 ORM 实现
  - 对象关系映射（Object Relational Mapping，ORM），用于实现面向对象编程语言里不同类型系统的数据之间的转换
- 动态 SQL

Mybatis的好处
- 把Sql语句从Java中独立出来。
- 封装了底层的JDBC，API的调用，并且能够将结果集自动转换成JavaBean对象，简化了Java数据库编程的重复工作。
- 自己编写Sql语句，更加的灵活。
- 入参无需用对象封装（或者map封装）,使用@Param注解

#### 3.1 sqlSession
Mybatis 的操作都是围绕一个 sqlSessionFactory 实例展开的。Mybatis 通过配置文件关联到各实体类的 Mapper 文件，Mapper 文件中配置了每个类对数据库所需进行的 sql 语句映射。在每次与数据库交互时，通过 sqlSessionFactory 拿到一个 sqlSession，再执行 sql 命令。

Mybatis 在核心处理类：SqlSession。SqlSession 重要的四个对象
1. `Execute`：调度执行 StatementHandler、ParmmeterHandler、ResultHandler 执行相应的SQL语句；
2. `StatementHandler`：使用数据库中 Statement（PrepareStatement）执行操作，即底层是封装好了的 prepareStatement；
3. `ParammeterHandler`：处理 SQL 参数；
4. `ResultHandler`：结果集 ResultSet 封装处理返回。

作用域和生命周期
- `SqlSessionFactoryBuilder`：这个类可以在任何时候被实例化、使用和销毁。一旦创造了 SqlSessionFactory 就不需要它了。所以SqlSessionFactoryBuilder 实例的最好的作用域是方法体内（即一个本地方法变量）。
- `SqlSessionFactory`：一旦创建，SqlSessionFactory 将会存在于您的应用程序整个运行生命周期中。很少或根本没有理由去销毁它或重新创建它。SqlSessionFactory 最好的作用域范围是一个应用的生命周期范围。
- `SqlSession`：每个线程都有一个 SqlSession 实例，SqlSession 实例是不被共享的，并且不是线程安全的。最好的作用域是 request 或者方法。
- `Mapper 实例`：Mappers 是创建来绑定映射语句的接口，Mapper 实例是从 SqlSession 得到的。因此，所有 mapper 实例的作用域跟创建它的SqlSession 一样。

#### 3.2 Mapper实例
Mybatis 的接口绑定：Mybatis 实现了 DAO 接口与 xml 映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。

SqlSession 运行步骤：
1. prepare 预编译 SQL；
2. parameterize 设置参数；
3. doUpdate/doQuery 执行 SQL；

类型处理器 TypeHandler：每当 MyBatis 设置参数到 PreparedStatement 或者从 ResultSet 结果集中取得值时，就会使用 TypeHandler 来处理数据库类型与 Java 类型之间转换。

Mybatis 的逆向工程中会生成实例及实例对应的 example，example 用于添加条件，相当 where 后面的部分。

传参方式
1. 传入一个参数 `#{参数名}`
2. 索引方式，传入多个参数 `#{0}、#{1}`
3. 传入多个参数，并且参数用@param注解 `#{参数名}`
4. 传入多个基本类型参数，参数用map封装，通过 `#{mapKey}` 取值
5. 使用map封装实体类,通过通过 `#{mapKey.attributeName}` 取值
6. 直接传入实体参数，通过 `#{属性名}` 取值

`${}` 与 `#{}`
- `#{}`：预编译处理，sql中的 `#{}` 替换成 `?`，补全预编译语句，有效的防止 Sql 语句注入，这种取值是编译好 SQL 语句再取值。拿到值之后拼装 sql，会自动对值添加单引号 `'`。
- `${}`：简单字符串替换，把 `${}` 直接替换成变量的值，不做任何转换，这种是取值以后再去编译 SQL 语句。拿到值之后拼装进 sql，如果需要加单引号 `'`，必须手动添加。需要添加属性 `statementType="STATEMENT"`。
