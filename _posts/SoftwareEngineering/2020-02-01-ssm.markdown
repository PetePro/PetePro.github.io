---
layout: post
title:  "【Java】SSM框架 总结 01 原理"
crawlertitle: "SSM原理"
summary: "Spring + SpringMVC + Mybatis"
date:   2020-02-01 09:00:00 +0800
categories: posts
tags: 'SE'
author: xusc
bg: "SE.jpg"
---

`SSM (Spring + SpringMVC + MyBatis)` 框架集由 Spring、MyBatis 两个开源框架整合而成，常作为数据源较简单的 Web 项目框架。本文总结SSM 框架的基本原理。

### Spring

概念：Spring 是一个开源的轻量级 Java SE /Java EE 开发应用框架，其目的是用于简化企业级应用程序开发。

简化开发
- ***面向 Bean***：IoC 容器通过配置文件或者注解的方式来管理对象之间的依赖关系
- ***IoC/DI（Inversion of Control 控制反转 / Dependency Injection 依赖注入）***
  - Spring 通过控制反转（IoC）的技术促进了松耦合。
  - 依赖注入 DI。把 DAO 依赖注入到 service 层，service 层反转给 action 层，Spring 顶层容器为 BeanFactory。
- ***AOP（Aspect Oriented Programming 面向切面）***：Spring 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现业务逻辑。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。
  - 实现原理：动态代理。
  - 面向切面编程：通过预编译和运行期动态代理的方式实现在不修改源代码的情况下给程序动态添加功能的技术

#### 系统架构
+ 核心容器：spring-beans、spring-core、spring-context、spring-expression
+ AOP 和设备支持：spring-aop、spring-aspects、spring-instrumentation
+ 数据访问及集成：spring-jdbc、spring-tx、spring-orm、spring-jms、spring-oxm
+ Web：spring-web、spring-webmvc、spring-websocket、spring-webmvc-portlet
+ 报文发送：spring-messaging
+ Test：spring-test

#### IoC/DI
IoC：想是反转资源获取的方向。传统的资源查找方式要求组件向容器发起请求查找资源，容器适时返回资源。而应用了 IOC 之后，则是容器主动将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接收资源，这种行为也被称为查找被动形式。

IOC 容器的初始化包括 BeanDefinition 的 Resource 定位、载入和注册这三个基本的过程

DI：IOC 的另一种表达形式，即组件以一些预先定义好的方式（例如：setter 方法）接收来自如容器的资源注入。相对于 IOC 而言，这种表达更直接。Spring DI 的三种方式，即为一个 bean 设置属性
1. 属性注入：通过 setter 方法初始化，使用 `<property>` 标签（最常用）
2. 构造器注入：通过构造方法初始化，保证了 Bean 实例在实例化后就可以使用，使用 `<constructor-arg>` 标签
3. 工厂方法注入：很少用，不推荐

字面值
- 可用字符串表示的值，可以通过 `<value>` 元素标签或 value 属性进行注入
- 基本数据类型及其封装类、String等类型都可以采取字面值注入的方式

依赖注入的时间
1. 用户第一次通过 getBean 方法向 IOC 容索要 Bean 时，IOC 容器触发依赖注入
2. 当用户在 Bean 定义资源中为 `<Bean>` 元素配置了 lazy-init 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入

#### bean及其实例化
两种类型的 IOC 容器实现，Spring Bean 的创建是典型的工厂模式
- BeanFactory 是 Spring 中比较原始、比较古老的 Factory。
- ApplicationContext 是 BeanFactory 的子类，基本上代替了 BeanFactory 的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展。
  - 负责读取 Spring 配置文件，管理对象加载，生成，维护 Bean 和 Bean 对象之间的依赖关系，负责 Bean 的生命周期等
  - ApplicationContext 的主要实现类
    - ClassPathXmlApplicationContext：从类路径下加载配置文件
    - FileSystemXmlApplicationContext：从文件系统中加载配置文件
    - WebApplicationContext：专门为 WEB 应用而准备的，从相对于 WEB 根目录的路径中完成初始化工作

配置 bean
- 命名空间：简化 xml 文件
- 自动装配（autowire）：将一个 Bean 注入到其他 Bean 的 Property 中
  - 与依赖注入的区分：依赖注入是一种设计模式，而 @autowired 是一种实现它的机制。
  - 模式：byType（根据类型自动装配）、byName（根据名称自动装配）、constructor（通过构造器自动装配，不建议使用）
- Spring 配置 bean 实例化的方式
  1. 使用类构造器实例化（默认无参数）
     `<bean id="bean1" class="cn.itcast.spring.b_instance.Bean1"></bean>`
  2. 使用静态工厂方法实例化（简单工厂模式）：调用 Bean2Factory 的 getBean2 方法得到 bean2
     `<bean id="bean2" class="cn.itcast.spring.b_instance.Bean2Factory" factory-method="getBean2"></bean>`
  3. 使用实例工厂方法实例化（工厂方法模式）：先创建工厂实例 bean3Facory，再通过工厂实例创建目标 bean 实例
     `<bean id="bean3Factory" class="cn.itcast.spring.b_instance.Bean3Factory"></bean>`
     `<bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"></bean>`



#### AOP







Spring事务管理：一般使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能。
- 编程式事务管理：编程方式管理事务，极大灵活性，难维护。
- 声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。主要选择。

Spring的配置文件中的内容
- 开启事务注解驱动
- 事务管理器
- 开启注解功能，并配置扫描包
- 配置数据库
- 配置SQL会话工厂，别名，映射文件
- 不用编写Dao层的实现类

Spring下的注解
- 注册：@Controller、@Service、@Repository
  - @Controller对应表现层的Bean，也就是Action。使用@Controller注解标识UserController之后，就表示要把UserController交给Spring容器管理，在Spring容器中会存在一个名字为“userController”的Action，这个名字是根据UserController类名来取的。
  - @Service对应的是业务层Bean。
  - @Repository对应数据访问层Bean。
- 注入：@Autowired与@Resource
  - @Autowired按byType自动注入，默认情况下必须要求依赖对象必须存在。
  - @Resource默认按byName自动注入，有两个重要属性name和type
  - @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。
- 请求地址：@RequestMapping
  - @RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。RequestMapping注解有六个属性：value、method、consumes、produces、params、headers。
- 返回具体数据类型而非跳转：@ResponseBody





Spring中主要的设计模式
- 工厂模式：每个Bean的创建通过方法
- 单例模式：默认的每个Bean的作用域都是单例
- 代理模式：关于AOP的实现通过代理模式
- 策略模式：定义一系列的算法，把它们一个个的封装起来，并且使它们可以相互替换。在实例化对象时用到

Spring生命周期：
1. getBean；
2. 调用bean的缺省构造函数；
3. 根据XML中的配置设置bean的相关属性；
4. 检查bean所实现的aware接口；
5. BeanPostProcessor前置处理；
6. 检查InitializingBean接口；
7. 检查init-method方法；
8. BeanPostProcessor后置处理；
9. In Use；
10. 检查Disposable接口；
11. destroy方法。



### SpringMVC
SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。

SpringMVC工作流程
1. 用户发送请求至前端控制器DispatcherServlet 
2. DispatcherServlet收到请求调用HandlerMapping处理器映射器。 
3. 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 
4. DispatcherServlet调用HandlerAdapter处理器适配器 
5. HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 
6. Controller执行完成返回ModelAndView 
7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet 
8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器 
9. ViewReslover解析后返回具体View 
10. DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 
11. DispatcherServlet响应用户

@RequestMapping注解用来映射一个URL到一个类或一个特定的方处理法上。

返回值
- SpringMVC中函数的返回值可以有很多类型，有String、ModelAndView、List、Set等，一般用String，如果是AJAX请求，返回的可以是一个集合
- SpringMVC根据配置文件中InternalResourceViewResolver（内部资源视图解析器）的前缀和后缀，用前缀+返回值+后缀组成完整的返回值
- 转发：在返回值前面加"forward:"
- 重定向：在返回值前面加"redirect:"



### Mybatis
Mybatis 是对 jdbc 的封装，它让数据库底层操作变的透明。Mybatis 的操作都是围绕一个 sqlSessionFactory 实例展开的。Mybatis 通过配置文件关联到各实体类的 Mapper 文件，Mapper 文件中配置了每个类对数据库所需进行的 sql 语句映射。在每次与数据库交互时，通过sqlSessionFactory 拿到一个 sqlSession，再执行 sql 命令。

Mybatis 的接口绑定：Mybatis 实现了 DAO 接口与 xml 映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。

MyBatis 优点
- 半自动化的 ORM 实现
  - 对象关系映射（Object Relational Mapping，ORM），用于实现面向对象编程语言里不同类型系统的数据之间的转换
- 动态 SQL

Mybatis的好处
- 把Sql语句从Java中独立出来。
- 封装了底层的JDBC，API的调用，并且能够将结果集自动转换成JavaBean对象，简化了Java数据库编程的重复工作。
- 自己编写Sql语句，更加的灵活。
- 入参无需用对象封装（或者map封装）,使用@Param注解

Mybatis在核心处理类：SqlSession。SqlSession重要的四个对象
1. Execute：调度执行StatementHandler、ParmmeterHandler、ResultHandler执行相应的SQL语句；
2. StatementHandler：使用数据库中Statement（PrepareStatement）执行操作，即底层是封装好了的prepareStatement；
3. ParammeterHandler：处理SQL参数；
4. ResultHandler：结果集ResultSet封装处理返回。

SqlSession运行步骤：
1. prepare预编译SQL；
2. parameterize设置参数；
3. doUpdate/doQuery执行SQL；

传参方式
1. 传入一个参数 `#{参数名}`
2. 索引方式，传入多个参数 `#{0}、#{1}`
3. 传入多个参数，并且参数用@param注解 `#{参数名}`
4. 传入多个基本类型参数，参数用map封装，通过 `#{mapKey}` 取值
5. 使用map封装实体类,通过通过 `#{mapKey.attributeName}` 取值
6. 直接传入实体参数，通过 `#{属性名}` 取值

`${}`与`#{}`
- `#{}`：预编译处理，sql中的`#{}`替换成`?`，补全预编译语句，有效的防止Sql语句注入，这种取值是编译好SQL语句再取值。拿到值之后拼装sql，会自动对值添加单引号`'`。
- `${}`：简单字符串替换，把`${}`直接替换成变量的值，不做任何转换，这种是取值以后再去编译SQL语句。拿到值之后拼装进sql，如果需要加单引号`'`，必须手动添加。需要添加属性`statementType="STATEMENT"`。
