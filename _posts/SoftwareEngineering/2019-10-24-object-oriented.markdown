---
layout: post
title:  "【OO】面向对象 总结 01 面向对象方法"
crawlertitle: "面向对象"
summary: "Object Oriented"
date:   2019-10-24 09:00:00 +0800
categories: posts
tags: 'SE'
author: xusc
bg: "SE.jpg"
---

`面向对象`是软件开发方法，是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。

### 四大特性
- 抽象：忽略一个主题中与当前目标无关的东西，专注于当前目标有关的方面。
  - 数据抽象——表示世界中一类事物的特征，就是对象的属性。
  - 行为抽象——表示世界中一类事物的行为，就是对象的行为。
- 封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。
  - `setter`、`getter`
- 继承
- 多态
  - 编译时多态——方法的重载
  - 运行时多态——程序中定义的对象引用所指向的具体类型在运行期间才确定。运行时多态有三个条件：
    - 继承
    - 覆盖（重写）
    - 向上转型：父类引用指向子类对象。

### 关系
- 泛化 (Generalization)：用来描述继承关系，在 Java 中使用 extends 关键字。
- 实现 (Realization)：用来实现一个接口，在 Java 中使用 implements 关键字。
- 聚合 (Aggregation)：表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。
- 组合 (Composition)：表示整体由部分组成，但是整体和部分是强依赖的，整体不存在了部分也不存在了。
- 关联 (Association)：表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。
- 依赖 (Dependency)：表示不同类对象之间有关联，依赖关系是在运行过程中起作用的。依赖的形式：
  - A 类是 B 类方法的局部变量；
  - A 类是 B 类方法的参数；
  - A 类向 B 类发送消息，从而影响 B 类发生变化。

### 设计原则
1. 单一职责原则（SRP）：修改一个类的原因应该只有一个。
2. 开放封闭原则（OCP）：类应该对扩展开放，对修改关闭。
3. 里氏替换原则（LSP）：子类对象必须能够替换掉所有父类对象。子类需要能够当成父类来使用，并且需要比父类更特殊。
4. 接口分离原则（ISP）：不应该强迫客户依赖于它们不用的方法。
5. 依赖倒置原则（DIP）：高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。具体来说：
   - 任何变量都不应该持有一个指向具体类的指针或者引用；
   - 任何类都不应该从具体类派生；
   - 任何方法都不应该覆写它的任何基类中的已经实现的方法。
6. 迪米特法则（LOD）：一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

### 设计模式
设计模式四个基本要素：模式名称、问题、解决方案、效果。

> MVC的主要关系由 Observer、Composite、Strategy 三个设计模式给出。

设计模式怎样解决问题
1. 寻找合适的对象：设计模式帮你确定并不明显的抽象和描述这些抽象的对象。
2. 决定对象的粒度。
3. 指定对象接口：通过确定接口的主要组成成分及接口发送的数据类型，来帮助你定义接口。
4. 描述对象的实现。
5. 运用复用机制。
6. 关联运行时刻和编译时刻的结构。
7. 设计应支持变化。

<table border="1">
    <tr>
        <th>类型</th>
        <th>设计模式</th>
        <th>可变的方面</th>
    </tr>
    <tr>
        <td rowspan="5">创建型</td>
        <td>抽象工厂</td>
        <td align="right">产品对象家族</td>
    </tr>
    <tr>
        <td>建造者</td>
        <td align="right">如何创建一个组合对象</td>
    </tr>
    <tr>
        <td>工厂模式</td>
        <td align="right">被实例化的子类</td>
    </tr>
    <tr>
        <td>原型</td>
        <td align="right">被实例化的类</td>
    </tr>
    <tr>
        <td>单例</td>
        <td align="right">一个类的唯一实例</td>
    </tr>
    <tr>
        <td rowspan="7">结构型</td>
        <td>适配器</td>
        <td align="right">对象的接口</td>
    </tr>
    <tr>
        <td>桥接</td>
        <td align="right">对象的实现</td>
    </tr>
    <tr>
        <td>组合</td>
        <td align="right">一个对象的结构和组成</td>
    </tr>
    <tr>
        <td>装饰者</td>
        <td align="right">对象的生成，不生成子类</td>
    </tr>
    <tr>
        <td>外观</td>
        <td align="right">一个子系统的接口</td>
    </tr>
    <tr>
        <td>享元</td>
        <td align="right">对象的存储开销</td>
    </tr>
    <tr>
        <td>代理</td>
        <td align="right">如何访问一个对象；该对象的位置</td>
    </tr>
    <tr>
        <td rowspan="11">行为型</td>
        <td>职责链</td>
        <td align="right">满足一个请求的对象</td>
    </tr>
    <tr>
        <td>命令</td>
        <td align="right">何时、怎样满足一个请求</td>
    </tr>
    <tr>
        <td>解释器</td>
        <td align="right">一个语言的文法及解释</td>
    </tr>
    <tr>
        <td>迭代器</td>
        <td align="right">如何遍历、访问一个聚合的各元素</td>
    </tr>
    <tr>
        <td>中介者</td>
        <td align="right">对象怎样交互、和谁交互</td>
    </tr>
    <tr>
        <td>备忘录</td>
        <td align="right">一个对象中哪些私有信息存放在该对象之外，以及什么时候进行存储</td>
    </tr>
    <tr>
        <td>观察者</td>
        <td align="right">多个对象依赖于另外一个对象，而这些对象又如何保持一致</td>
    </tr>
    <tr>
        <td>状态</td>
        <td align="right">对象的状态</td>
    </tr>
    <tr>
        <td>策略</td>
        <td align="right">算法</td>
    </tr>
    <tr>
        <td>模板方法</td>
        <td align="right">算法中的某些步骤</td>
    </tr>
    <tr>
        <td>访问者</td>
        <td align="right">某些可作用于一个（组）对象上的操作，但不修改这些对象的类</td>
    </tr>
</table>

设计模式之间的关系
![](/assets/images/2020/designpattern.png)

#### 总结
**创建型**  
用一个系统创建的对象的类对系统进行参数化有两种方法
1. 生成创建对象的类的子类。缺点在于仅未来改变产品类，就可能需要创建一个新的子类。
2. 依赖于对象复合：定义一个负责明确产品对象的类，并将它作为该系统的参数。

**结构型**  
结构型模式依赖于同一个很小的语言机制集合构造代码和对象
- 单继承和多重继承机制用于基于类的模式
- 对象机制用于对象式模式
- 结构类似的模式
  - Adapter 与 Bridge 常被用于软件生命周期的不同阶段：Bridge 在设计类之前实施，Adapter 在类设计好后实施。
  - Composite 和 Decorator 都基于递归组合来组织可变数目的对象，通常协同使用。
  - Decorator 和 Proxy 都描述了怎样为对象提供一定程度上的间接引用。

**行为型**  
各个行为模式之间是相互补充和相互加强的关系。

设计模式带来的影响
1. 一套通用的设计词汇
2. 书写文档和学习的辅助手段
3. 现有方法的一种补充
4. 为重构提供了目标