---
layout: post
title:  "【Java】Java 总结 02 Java虚拟机"
crawlertitle: "Java虚拟机"
summary: "Java Virtual Machine"
date:   2020-02-08 09:00:00 +0800
categories: posts
tags: 'CS'
author: xusc
bg: "CS.jpg"
---

`Java` 是一门面向对象编程语言，不仅吸收了 C++ 语言的各种优点，还摒弃了 C++ 里难以理解的多继承、指针等概念，因此 Java 语言具有功能强大和简单易用两个特征。Java 语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。


### [Java虚拟机](#目录)

#### 运行时数据区域

![](/assets/images/2019/JVM.png)

- **程序计数器**记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
- **Java 虚拟机栈**：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。
- **本地方法栈**：本地方法栈与 Java 虚拟机栈类似，但它为本地方法服务。
- **堆**：所有对象都在这里分配内存，是垃圾收集的主要区域。堆被划分成两个不同的区域：新生代（Young）、老年代（Old）。新生代又被划分为三个区域：Eden、S0、S1。
  - *新生代*用来存放新近创建的对象，尺寸随堆大小的增大和减小而相应的变化，默认值是保持为堆大小的 1/15。新生代的特点是产生大量的死亡对象。
  - *老年代*里面的对象基本都是在 Survivor 区域中熬过来的，不会轻易死亡。
  - *永久代*是方法区的一种实现。在 Java8 中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间。
- **方法区**：用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
  - 运行时常量池：运行时常量池是方法区的一部分。Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。
- **直接内存**：在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。

#### 垃圾回收
垃圾回收主要是针对堆和方法区进行。
- 判断一个对象是否可被回收
  1. 引用计数算法：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
  2. 可达性分析算法：以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
  3. 方法区的回收：主要是对常量池的回收和对类的卸载。
- Java 提供了四种强度不同的引用类型。
  1. 强引用：被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。
  2. 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。
  3. 弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。
  4. 虚引用：在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。
- 垃圾回收算法
  1. 标记 - 清除
  2. 标记 - 整理
  3. 复制
  4. 分代收集
     - 新生代使用：复制算法
     - 老年代使用：标记 - 清除 / 标记 - 整理
- 垃圾回收器
  - Serial 收集器：串行、单线程，Client 场景下的默认新生代收集器。
  - ParNew 收集器：Serial 收集器的多线程版本，Server 场景下默认的新生代收集器。
  - Parallel Scavenge 收集器：多线程，目标是达到一个可控制的吞吐量。
  - Serial Old 收集器：Serial 收集器的老年代版本。
  - Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本。
  - CMS 收集器：Concurrent Mark Sweep（标记 - 清除）。
  - G1 收集器：面向服务端应用的垃圾收集器。

#### 内存分配与回收
- 内存分配策略
  1. 对象优先在 Eden 分配
  2. 大对象直接进入老年代
  3. 长期存活的对象进入老年代
  4. 动态对象年龄判定
  5. 空间分配担保
- Minor GC 和 Full GC
  - Minor GC：回收新生代
    - 速度较快
    - 复制算法
    - 并行收集器
    - 触发条件：当 Eden 空间满时。
  - Full GC：回收老年代和新生代
    - 速度较慢
    - 标记 - 清除算法
    - 触发条件：
      - 调用 System.gc()
      - 老年代空间不足
      - 空间分配担保失败
      - JDK 1.7 及以前的永久代空间不足
      - Concurrent Mode Failure

#### 类加载机制
- 类的生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）
- 类加载过程：加载、验证、准备、解析、初始化
- 类初始化时机：主动引用、被动引用
- 类加载器：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）




