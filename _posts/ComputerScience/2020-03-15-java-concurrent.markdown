---
layout: post
title:  "【Java】Java"
crawlertitle: "Java"
summary: "Java"
date:   2019-10-24 09:00:00 +0800
categories: posts
tags: 'CS'
author: xusc
bg: "CS.jpg"
---

Java并发编程汇总

### Java并发

#### 线程
- 有三种使用线程的方法：
  1. 实现 Runnable 接口——使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。；
  2. 实现 Callable 接口；
  3. 继承 Thread 类—— Thread 类也实现了 Runable 接口。
- 实现接口优于继承 Thread：
  - Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
  - 类可能只要求可执行就行，继承整个 Thread 类开销过大。
- Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。
- Daemon 守护线程是程序运行时在后台提供服务的线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。
- Thread.sleep(millisec) 方法会休眠当前正在执行的线程。
- 线程中抛出的异常需要在本地进行处理。
- J.U.C 即java.util .concurrent工具包，这是一个处理线程的工具包，大大提高了并发性能，AQS 是 J.U.C 的核心。

#### 中断
- 通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 - InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。调用 interrupt() 方法会设置线程的中断标记。
- 调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。

#### 互斥同步

—|synchronized|ReentrantLock
:-:|:-:|:-:
实现|JVM|JDK
可否中断|不可|可以
是否公平锁|非公平|非公平，也可以公平

synchronized
- 同步一个代码块或方法——作用于同一个对象
- 同步一个类或静态方法——作用于整个类

#### 协作
- join() 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。
- 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。
  - wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
  - wait() 会释放锁，sleep() 不会。
- 可以在 Condition 类上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。await() 可以指定等待的条件，因此更加灵活。

#### 线程状态
- 新建（NEW）
- 可运行（RUNABLE）：正在 Java 虚拟机中运行。在操作系统层面，它可能处于运行状态，也可能等待资源调度。
- 阻塞（BLOCKED）：等待获取 monitor lock。阻塞是被动的
- 无限期等待（WAITING）：等待其它线程显式地唤醒。等待是主动的。进入方法：
  - 没有设置 Timeout 参数的 Object.wait() 方法
  - 没有设置 Timeout 参数的 Thread.join() 方法
- 限期等待（TIMED_WAITING）：一定时间之后会被系统自动唤醒。进入方法：
  - Thread.sleep()
  - 设置了 Timeout 参数的 Object.wait() 方法
  - 设置了 Timeout 参数的 Thread.join() 方法
- 死亡（TERMINATED）

#### 线程安全
线程安全有以下几种实现方式：
- 不可变（Immutable）的对象一定是线程安全的
  - final 关键字修饰的基本数据类型
  - String
  - 枚举类型
  - Number 部分子类
- 互斥同步 synchronized 和 ReentrantLock。
- 非阻塞同步：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种并发策略的许多实现都不需要将线程阻塞。
  - 比较并交换（Compare-and-Swap，CAS）
  - J.U.C 包里面的整数原子类 AtomicInteger 的方法
  - 如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。
- 无同步方案
  - 栈封闭
  - 线程本地存储
  - 可重入代码

#### 锁
- 乐观锁/悲观锁
  - 乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制（版本号、时间戳）”或“CAS操作”来实现。
  - 悲观锁认为对于同一个数据的并发操作，一定会发生修改的。
- 独享锁/共享锁
  - 独享锁是指该锁一次只能被一个线程所持有。
  - 共享锁是指该锁可被多个线程所持有。
- 互斥锁/读写锁
  - 互斥锁/读写锁是独享锁/共享锁的具体实现
  - ReentrantLock
  - ReadWriteLock
- 可重入锁：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
- 公平锁/非公平锁
  - 公平锁是指多个线程按照申请锁的顺序来获取锁。
  - 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序。
- 分段锁：分段锁是一种锁的设计，目的是细化锁的粒度。
- 偏向锁/轻量级锁/重量级锁：这三种锁是指锁的状态，并且是针对Synchronized。
  - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
  - 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
  - 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。
- 自旋锁：自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁

#### 锁优化
JVM 对 synchronized 的优化
- 自旋锁：让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。
- 锁消除：对于被检测出不可能存在竞争的共享数据的锁进行消除。
- 锁粗化：如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。
- 轻量级锁：是相对于传统的重量级锁而言，它使用 CAS操作来避免重量级锁使用互斥量的开销。
- 偏向锁：是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作。

#### 建议
- 给线程起个有意义的名字；
- 缩小同步范围，从而减少锁争用；
- 多用同步工具少用 wait() 和 notify()；
- 使用 BlockingQueue 实现生产者消费者问题；
- 多用并发集合少用同步集合；
- 使用本地变量和不可变类来保证线程安全；
- 使用线程池而不是直接创建线程。