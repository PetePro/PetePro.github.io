---
layout: post
title:  "【Java】Java 总结 03 并发编程"
crawlertitle: "Java并发编程"
summary: "Java Concurrency"
date:   2020-03-15 09:00:00 +0800
categories: posts
tags: 'CS'
author: xusc
bg: "CS.jpg"
---

`并发编程`是 Java 的重要特性之一，在 Java 平台上提供了许多基本的并发功能来辅助开发多线程应用程序。

多线程的价值
- 发挥多处理器的能力
- 建模的简单性
- 异步事件的简化处理
- 响应更灵敏的用户界面

多线程的风险
- 安全性
- 活跃性
- 性能问题

并发编程三要素
- **原子性**：指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。
- **可见性**：指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。
- **有序性**：即程序的执行顺序按照代码的先后顺序来执行。

#### 使用线程
线程类的构造方法、静态块是被 new 这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。

线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。

时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。

1. 继承 `Thread` 类—— Thread 类也实现了 Runable 接口；
2. 实现 `Runnable` 接口——使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程；
3. 实现 `Callable` 接口；

比较|Callable|Runnable
:-:|:-:|:-:
规定（重写）方法|call()|run()
任务返回|可返回值|不可返回值
异常|可抛异常|不可抛异常
其它|可拿到一个 Future 对象<br/>表示异步计算的结果|



比较|实现接口|继承Thread
:-:|:-:|:-:
开销|小|大
编程|复杂|简单
当前线程|Thread.currentThread()|this
面向对象|还可以继承其他类|不能再继承其他父类
其它|多个线程可共享同个 target 对象|

线程状态
- 新建（NEW）
- 可运行（RUNABLE）：正在 Java 虚拟机中运行。在操作系统层面，它可能处于运行状态，也可能等待资源调度。
- 阻塞（BLOCKED）：等待获取 monitor lock。阻塞是被动的
- 无限期等待（WAITING）：等待其它线程显式地唤醒。等待是主动的。进入方法：
  - 没有设置 Timeout 参数的 Object.wait() 方法
  - 没有设置 Timeout 参数的 Thread.join() 方法
- 限期等待（TIMED_WAITING）：一定时间之后会被系统自动唤醒。进入方法：
  - Thread.sleep()
  - 设置了 Timeout 参数的 Object.wait() 方法
  - 设置了 Timeout 参数的 Thread.join() 方法
- 死亡（TERMINATED）

#### 线程池

线程池，java.util.concurrent.Executor 接口
1. `newCachedThreadPool` 创建一个可缓存线程池
2. `newFixedThreadPool` 创建一个定长线程池，可控制线程最大并发数
3. `newScheduledThreadPool` 创建一个定长线程池，支持定时及周期性任务执行
4. `newSingleThreadExecutor` 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务

线程池优点
1. 重用存在的线程，减少对象创建销毁的开销。
2. 可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
3. 提供定时执行、定期执行、单线程、并发数控制等功能。

你提交任务时，线程池队列已满
1. 如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，可以继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务
2. 如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy

#### 线程机制

Executors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 Callable 类提供了一些工具方法。Executors 可以用于方便的创建线程池

`Executor` 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。主要有三种 Executor：
- CachedThreadPool：一个任务创建一个线程；
- FixedThreadPool：所有任务只能使用固定大小的线程；
- SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。

`Daemon` 守护线程是程序运行时在后台提供服务的线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。

`Thread.sleep(millisec)` 方法会休眠当前正在执行的线程。

线程中抛出的异常需要在本地进行处理。

对静态方法 `Thread.yield()` 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。


#### 中断
- 通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 - InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。调用 interrupt() 方法会设置线程的中断标记。
- 如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。
- 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。
- 调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。

Future 表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加 Callback 以便在任务执行成功或失败后作出相应的操作。

线程停止条件
1. 线程体中调用了 yield 方法让出了对 CPU 的占用权利
2. 线程体中调用了 sleep 方法使线程进入睡眠状态
3. 线程由于 IO 操作受到阻塞
4. 另外一个更高优先级线程出现
5. 在支持时间片的系统中，该线程的时间片用完

#### 互斥同步

`synchronized` 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。属于悲观锁。
- 同步一个代码块或方法——作用于同一个对象
- 同步一个类或静态方法——作用于整个类
- 原则：同步的范围越小越好。

`ReentrantLock` 是 java.util.concurrent（J.U.C）包中的锁。

比较|synchronized|ReentrantLock
:-:|:-:|:-:
本质区别|关键字|类
实现|JVM|JDK
可否中断|不可|可以
是否公平锁|非公平|非公平，也可以公平

`Semaphore` 就是一个信号量，它的作用是限制某段代码块的并发数。如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。

`volatile` 关键字保证了可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。volatile 的一个重要作用就是和 CAS 结合，保证了原子性。

`ThreadLocal` 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。

并发工具类
- CountDownLatch：一个线程等待，直到他所等待的其他线程都执行完成并且调用 countDown()方法发出通知后，当前线程才可以继续执行
- CyclicBarrier：所有线程都进行等待，直到所有线程都准备好进入 await()方法之后，所有线程同时开始执行
- Semaphore
- Exchanger


Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。
1. 可以使锁更公平
2. 可以使线程在等待锁的时候响应中断
3. 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
4. 可以在不同的范围，以不同的顺序获取和释放锁

#### 协作
- join() 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。
- 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。JDK 强制要在同步块中被调用，在调用前都必须先获得对象的锁。
  - wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
  - wait() 会释放锁，sleep() 不会。
  - sleep() 方法不会放弃这个对象的监视器，wait() 方法会放弃这个对象的监视器
- 可以在 Condition 类上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。await() 可以指定等待的条件，因此更加灵活。

#### JUC

`J.U.C` 即 `java.util.concurrent` 工具包，这是一个处理线程的工具包，大大提高了并发性能，AQS 是 J.U.C 的核心。

- CountDownLatch 用来控制一个或者多个线程等待多个线程。
- CyclicBarrier 用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。
- Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。



`AQS` 是 `AbustactQueuedSynchronizer` 的简称，它是一个 Java 提高的底层同步工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管理这个同步状态。AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器。AQS 同步方式：
1. 独占式 ReentrantLock
2. 共享式 Semaphore、CountDownLatch
3. 组合式 ReentrantReadWriteLock

FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。

java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：
- FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）
- 优先级队列 ：PriorityBlockingQueue






#### 线程安全
线程安全有以下几种实现方式：
- 不可变（Immutable）的对象一定是线程安全的
  - final 关键字修饰的基本数据类型
  - String
  - 枚举类型
  - Number 部分子类
- 互斥同步 synchronized 和 ReentrantLock。
- 非阻塞同步：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种并发策略的许多实现都不需要将线程阻塞。
  - 比较并交换（Compare-and-Swap，CAS）
  - J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作
- 无同步方案
  - 栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。
  - 线程本地存储：可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。
  - 可重入代码

单例模式的线程安全性
  - 饿汉式单例模式：线程安全
  - 懒汉式单例模式：非线程安全
  - 双检锁单例模式：线程安全

`CAS` 是 `compare and swap` 的缩写，即比较和交换。一种基于锁的操作，而且是乐观锁。
- CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）
- 如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被 b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。

CAS 的问题
- CAS 容易造成 ABA 问题：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。
- 不能保证代码块的原子性
- CAS 造成 CPU 利用率增加



#### 锁
- 乐观锁/悲观锁
  - 乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制（版本号、时间戳）”或“CAS操作”来实现。
  - 悲观锁认为对于同一个数据的并发操作，一定会发生修改的。
- 独享锁/共享锁
  - 独享锁是指该锁一次只能被一个线程所持有。
  - 共享锁是指该锁可被多个线程所持有。
- 互斥锁/读写锁
  - 互斥锁/读写锁是独享锁/共享锁的具体实现
  - ReentrantLock
  - ReadWriteLock
- 可重入锁：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
- 公平锁/非公平锁
  - 公平锁是指多个线程按照申请锁的顺序来获取锁。
  - 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序。
- 分段锁：分段锁是一种锁的设计，目的是细化锁的粒度。
- 偏向锁/轻量级锁/重量级锁：这三种锁是指锁的状态，并且是针对Synchronized。
  - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
  - 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
  - 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。
- 自旋锁：自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁

JVM 对 synchronized 的优化
- 自旋锁：让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。
- 锁消除：对于被检测出不可能存在竞争的共享数据的锁进行消除。
- 锁粗化：如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。
- 轻量级锁：是相对于传统的重量级锁而言，它使用 CAS操作来避免重量级锁使用互斥量的开销。
- 偏向锁：是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作。

#### 建议
- 给线程起个有意义的名字；
- 缩小同步范围，从而减少锁争用；
- 多用同步工具少用 wait() 和 notify()；
- 使用 BlockingQueue 实现生产者消费者问题；
- 多用并发集合少用同步集合；
- 使用本地变量和不可变类来保证线程安全；
- 使用线程池而不是直接创建线程。





#### Java内存模型
Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。
- 主内存与工作内存
  - 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中
  - 线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。
- Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作
  - 作用于主内存的变量：read、write、lock、unlock
  - 作用于线程的工作内存的变量：load、use、assign、store、
- 关键字 volatile 是 Java 虚拟机中提供的最轻量级的同步机制
  - volatile类型的变量保证对所有线程的可见性。
  - volatile类型的变量禁止指令重排序优化。
- 内存模型三大特性：原子性、可见性、有序性
- JVM 规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。