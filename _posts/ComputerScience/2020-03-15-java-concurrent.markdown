---
layout: post
title:  "【Java】Java"
crawlertitle: "Java"
summary: "Java"
date:   2019-10-24 09:00:00 +0800
categories: posts
tags: 'CS'
author: xusc
bg: "CS.jpg"
---

Java并发编程汇总

### 并发

并发编程三要素
- **原子性**：指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。
- **可见性**：指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。
- **有序性**：即程序的执行顺序按照代码的先后顺序来执行。

多线程的价值
- 发挥多核 CPU 的优势
- 防止阻塞
- 便于建模



### 线程

#### 创建线程

1. 继承 `Thread` 类—— Thread 类也实现了 Runable 接口；
2. 实现 `Runnable` 接口——使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。；
3. 实现 `Callable` 接口；
4. 线程池。提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。

比较|Callable|Runnable
:-:|:-:|:-:
规定（重写）方法|call()|run()
任务返回|可返回值|不可返回值
异常|可抛异常|不可抛异常
其它|可拿到一个 Future 对象<br/>表示异步计算的结果|

比较|实现接口|继承Thread
:-:|:-:|:-:
开销|小|大
编程|复杂|简单
当前线程|Thread.currentThread()|this
面向对象|还可以继承其他类|不能再继承其他父类
其它|多个线程可共享同个 target 对象|

- `Executor` 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。
- `Daemon` 守护线程是程序运行时在后台提供服务的线程。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。
- Thread.sleep(millisec) 方法会休眠当前正在执行的线程。
- 线程中抛出的异常需要在本地进行处理。
- J.U.C 即java.util.concurrent工具包，这是一个处理线程的工具包，大大提高了并发性能，AQS 是 J.U.C 的核心。

线程池，java.util.concurrent.Executor 接口
1. `newCachedThreadPool` 创建一个可缓存线程池
2. `newFixedThreadPool` 创建一个定长线程池，可控制线程最大并发数
3. `newScheduledThreadPool` 创建一个定长线程池，支持定时及周期性任务执行
4. `newSingleThreadExecutor` 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务

线程池有点
1. 重用存在的线程，减少对象创建销毁的开销。
2. 可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
3. 提供定时执行、定期执行、单线程、并发数控制等功能。


#### 线程状态
- 新建（NEW）
- 可运行（RUNABLE）：正在 Java 虚拟机中运行。在操作系统层面，它可能处于运行状态，也可能等待资源调度。
- 阻塞（BLOCKED）：等待获取 monitor lock。阻塞是被动的
- 无限期等待（WAITING）：等待其它线程显式地唤醒。等待是主动的。进入方法：
  - 没有设置 Timeout 参数的 Object.wait() 方法
  - 没有设置 Timeout 参数的 Thread.join() 方法
- 限期等待（TIMED_WAITING）：一定时间之后会被系统自动唤醒。进入方法：
  - Thread.sleep()
  - 设置了 Timeout 参数的 Object.wait() 方法
  - 设置了 Timeout 参数的 Thread.join() 方法
- 死亡（TERMINATED）






#### 中断
- 通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 - InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。调用 interrupt() 方法会设置线程的中断标记。
- 调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。

#### 互斥同步

`synchronized` 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。
- 同步一个代码块或方法——作用于同一个对象
- 同步一个类或静态方法——作用于整个类

`volatile` 关键字保证了可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。volatile 的一个重要作用就是和 CAS 结合，保证了原子性。

比较|synchronized|ReentrantLock
:-:|:-:|:-:
本质区别|关键字|类
实现|JVM|JDK
可否中断|不可|可以
是否公平锁|非公平|非公平，也可以公平

CAS 是 compare and swap 的缩写，即我们所说的比较交换。
- CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）
- 如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。

CAS 的问题
- CAS 容易造成 ABA 问题
- 不能保证代码块的原子性
- CAS 造成 CPU 利用率增加



#### 协作
- join() 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。
- 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。
  - wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
  - wait() 会释放锁，sleep() 不会。
- 可以在 Condition 类上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。await() 可以指定等待的条件，因此更加灵活。



#### 线程安全
线程安全有以下几种实现方式：
- 不可变（Immutable）的对象一定是线程安全的
  - final 关键字修饰的基本数据类型
  - String
  - 枚举类型
  - Number 部分子类
- 互斥同步 synchronized 和 ReentrantLock。
- 非阻塞同步：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种并发策略的许多实现都不需要将线程阻塞。
  - 比较并交换（Compare-and-Swap，CAS）
  - J.U.C 包里面的整数原子类 AtomicInteger 的方法
  - 如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。
- 无同步方案
  - 栈封闭
  - 线程本地存储
  - 可重入代码

#### 锁
- 乐观锁/悲观锁
  - 乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制（版本号、时间戳）”或“CAS操作”来实现。
  - 悲观锁认为对于同一个数据的并发操作，一定会发生修改的。
- 独享锁/共享锁
  - 独享锁是指该锁一次只能被一个线程所持有。
  - 共享锁是指该锁可被多个线程所持有。
- 互斥锁/读写锁
  - 互斥锁/读写锁是独享锁/共享锁的具体实现
  - ReentrantLock
  - ReadWriteLock
- 可重入锁：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
- 公平锁/非公平锁
  - 公平锁是指多个线程按照申请锁的顺序来获取锁。
  - 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序。
- 分段锁：分段锁是一种锁的设计，目的是细化锁的粒度。
- 偏向锁/轻量级锁/重量级锁：这三种锁是指锁的状态，并且是针对Synchronized。
  - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
  - 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
  - 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。
- 自旋锁：自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁

#### 锁优化
JVM 对 synchronized 的优化
- 自旋锁：让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。
- 锁消除：对于被检测出不可能存在竞争的共享数据的锁进行消除。
- 锁粗化：如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。
- 轻量级锁：是相对于传统的重量级锁而言，它使用 CAS操作来避免重量级锁使用互斥量的开销。
- 偏向锁：是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作。

#### 建议
- 给线程起个有意义的名字；
- 缩小同步范围，从而减少锁争用；
- 多用同步工具少用 wait() 和 notify()；
- 使用 BlockingQueue 实现生产者消费者问题；
- 多用并发集合少用同步集合；
- 使用本地变量和不可变类来保证线程安全；
- 使用线程池而不是直接创建线程。