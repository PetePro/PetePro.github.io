---
layout: post
title:  "【OO】设计模式"
crawlertitle: "Design Pattern"
summary: "Design Pattern"
date:   2019-12-21 09:00:00 +0800
categories: posts
tags: 'CSSE'
author: xusc
---

设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

### 分类
- [**创建型**](#创建型)
  - [*单例模式*](#单例模式)
  - [*简单工厂模式*](#简单工厂模式)
  - [*工厂方法模式*](#工厂方法模式)
  - [*抽象工厂模式*](#抽象工厂模式)
  - [*原型模式*](#原型模式)
- [**行为型**](#行为型)
- [**结构型**](#结构型)

### 创建型
创建型模式（Creational Pattern）对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

#### [单例模式](#目录)
[Singleton Pattern](https://github.com/PetePro/DesignPattern-in-Java/tree/master/src/creational/singleton)
- 定义：确保一个类只有一个实例，并提供该实例的全局访问点。
- 特点：使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
- 优点：提供了对唯一实例的受控访问；可以节约系统资源。
- 缺点：因为缺少抽象层而难以扩展；单例类职责过重。
- 场景：
  - 系统只需要一个实例对象；
  - 客户调用类的单个实例只允许使用一个公共访问点。
- 实现方式：
  1. 懒汉式-线程不安全
  2. 饿汉式-线程安全
  3. 懒汉式-线程安全
  4. 双重校验锁-线程安全
  5. 静态内部类
  6. 枚举

#### [简单工厂模式](#目录)
[Simple Factory Pattern](https://github.com/PetePro/DesignPattern-in-Java/tree/master/src/creational/simplefactory)
- 定义：又称为静态工厂方法（Static Factory Method）模式。在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。
- 特点：简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，被创建的实例通常都具有共同的父类。
- 优点：实现对象的创建和对象的使用分离。
- 缺点：不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码；产品较多时，工厂方法代码将会非常复杂。
- 场景：
  - 工厂类负责创建的对象比较少；
  - 客户端只知道传入工厂类的参数，对于如何创建对象不关心。

#### [工厂方法模式](#目录)
[Factory Pattern](https://github.com/PetePro/DesignPattern-in-Java/tree/master/src/creational/factorymethod)
- 定义：定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
- 特点：在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。
- 优点：增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性。
- 缺点：增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。
- 场景：
  - 一个类不知道它所需要的对象的类；
  - 一个类通过其子类来指定创建哪个对象；
  - 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。

#### [抽象工厂模式](#目录)
[Abstract Factory Pattern](https://github.com/PetePro/DesignPattern-in-Java/tree/master/src/creational/abstractfactory)
- 定义：提供一个接口，用于创建相关的对象家族。围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。
- 特点：抽象工厂模式创建的是对象家族，而工厂方法模式只是用于创建一个对象。抽象工厂模式用到了工厂方法模式来创建单一对象。
- 优点：隔离了具体类的生成，使得客户并不需要知道什么被创建；每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便。
- 缺点：增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。
- 场景：
  - 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；
  - 系统中有多于一个的产品族，而每次只使用其中某一产品族；
  - 属于同一个产品族的产品将在一起使用；
  - 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

#### [原型模式](#目录)
[Prototype Pattern](https://github.com/PetePro/DesignPattern-in-Java/tree/master/src/creational/prototype)
- 定义：使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。
- 特点：这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。
- 优点：性能提高；逃避构造函数的约束。
- 缺点：配备克隆方法需要对类的功能进行通盘考虑；必须实现 Cloneable 接口。
- 场景：
  - 类初始化需要消化非常多的资源；
  - new 产生一个对象需要非常繁琐的数据准备或访问权限；
  - 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值；
  - 原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。

#### [建造者模式](#目录)
[Builder Pattern](https://github.com/PetePro/DesignPattern-in-Java/tree/master/src/creational/builder)
- 定义：封装一个对象的构造过程，并允许按步骤构造。
- 特点：一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。
- 优点：客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”；可以更加精细地控制产品的创建过程
- 缺点：由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。
- 场景：
  - 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；
  - 需要生成的产品对象的属性相互依赖，需要指定其生成顺序；
  - 对象的创建过程独立于创建该对象的类；
  - 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。



### 行为型
行为型模式（Behavioral Pattern）是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。



### 结构型
结构型模式（Structural Pattern）描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。